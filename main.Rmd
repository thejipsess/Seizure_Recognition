---
title: "Seizure Recognition"
author: "Jip de Kok"
date: "9/15/2020"
output:
  html_document: default
  pdf_document: default
---

The data used here is EEG data. Originally there were 500 participants, who
were recorded for 23.5 seconds with 4097 data points per sample. Each sample
was divided into 23 chunks , each containing 178 data points for 1 second.
These chunks were shuffled, resulting in 11500 samples.


5 - (healthy, surface recording) eyes open, means when they were recording the EEG signal of the brain the patient had their eyes open
4 - (healthy, surface recording) eyes closed, means when they were recording the EEG signal the patient had their eyes closed
3 - (epiliptic, intracranial recording) The EEG activity from the hippocampal formation in the non-epiletogenic hemisphere with no seizure
2 - (epiliptic, intracranial recording) The EEG activity from the epileptogenic zone brain area with no seizure
1 - (epiliptic, intracranial recording) Recording of seizure activity



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


This section loads all the the required packages and the data. Also, it removes missing data and splits the data into dependant and independant data.
```{r data, echo=FALSE, message = FALSE}
source('packages.R')

# Load data
x = read.csv('Data/data.csv', sep = ';', row.names = 'X')
# Remove rows with missing data
x <- na.omit(x)

# Permute y to create random data
set.seed(4685)
x$y <- sample(x$y)
  
# Isolate y
y <- x$y

# remove y column from x
x <- subset(x, select = -y)

```

```{r Data_Inspection}
# Count missing data
nullsum = sum(!complete.cases(x))

theme_set(theme_bw(base_size=12)+ 
  theme(panel.grid.major = element_blank(),
  panel.grid.minor = element_blank()))

# Plot a random sample over time
plot_rand_sample(x)

```

```{r PCA}
# Perform PCA
pca <- prcomp(x, center = TRUE, scale=FALSE)

# Plot PCA
plot_pca(pca, y)

# Remove the sample with class 70
x <- x[y != 70,]
y <- y[y != 70]

```

```{r Plot_data_before}
# Create density plot of unnormalised data
plot_dens(x, "Data distribution (not pre-processed)")

# Make violin plots for the different classes
plot_violin(x, y, title = "violin plot for all classes (not pre-processed)")

# Create boxplots
plot_boxplot(x, y)
```


```{r Preprocessing}

# Mean center and scale (divide by stdev) the data
#preproc <- preProcess(x, method=c('center', 'scale'))
#x <- predict(preproc, x)

# Get rid of the most extreme outlier
row_max <- which(x == max(x), arr.ind = TRUE)[1]
y <- y[-row_max]
x <- x[-row_max,]


# Remove univariate outliers
for(i in seq(1, 178)){
  Q1 <- quantile(x[,i], 0.25)
  Q3 <- quantile(x[,i], 0.75)
  IQR <- Q3 - Q1
  uplim <- Q3 + 10*IQR
  downlim <- Q1 - 10*IQR
  
  y <- y[x[names(x)[i]] <= uplim & x[names(x)[i]] >= downlim]
  x <- x[x[names(x)[i]] <= uplim & x[names(x)[i]] >= downlim,]
}

# mean-center: Set mean of each variable to 0
# Scale: Unit variance scaling
preproc <- preProcess(x, method=c('center')) # Can also add 'scale'
x <- predict(preproc, x)

# Min Max normalisation
for (col in colnames(x)){
  x[col] <- ((x[col] - min(x[col])) / (max(x[col]) - min(x[col])))
}

```


```{r Plot_data_after}
# Create density plot of unnormalised data
plot_dens(x, "Data distribution (pre-processed)")

# Make violin plots for the different classes
plot_violin(x, y, title = "violin plot for all classes (not pre-processed)")

# Create boxplots
plot_boxplot(x, y)
```


``` {r distance, message=FALSE}
# create matrix z which contains both x and y, only for classes one and two
z <- x
z$y <- y
z <- z[y == 1 | y == 2,]
z <- arrange(z, y)

# Calculate the distance matrix (euclidean distance)
distance <- dist(z[,-ncol(z)])
distance <- as.matrix(distance)

# Plot heatmap of the distance matrix
plot_heatmap(distance, save = TRUE, title = "Distance heatmap - no scaling")

# Perform double centring on the distance matrix
Rmean <- distance*0 + rowMeans(distance)
Cmean <- distance*0 + colMeans(distance)
distance = distance - Rmean - Cmean + mean(distance)

# Plot heatmap of the double centered distance matrix
plot_heatmap(distance, save = TRUE, title = "Distance heatmap - double centered")

# Perform PCA on normal data for class 1 & 2
pca <- prcomp(z[,-ncol(z)], center = TRUE, scale=FALSE)

# Plot PCA plots including 3D score plot
plot_pca(pca, y = z$y, title = "on class 1 & 2", save=TRUE, include_3D = TRUE, PC_x = 1, PC_y = 2, PC_z=3)

# Perform PCA on euclidean distance for class 1 & 2
pca_dist <- prcomp(distance, center = TRUE, scale=FALSE)

# Open new RGL device to allow both 3D plots to be active simultaneously
open3d()

# Plot PCA plots including 3D score plot
plot_pca(pca_dist, y = z$y, title = "on euclidean distance", save=TRUE, include_3D = TRUE, PC_x = 1, PC_y = 2, PC_z=3)
```

```{r gaussian_kernel}

rbfkernel <- rbfdot(sigma = 0.1)

f <- kernelMatrix(rbfkernel, as.matrix(z))

pca <- prcomp(f, center = TRUE, scale=FALSE)

plot_pca(pca, y = z$y, title = "kernel", save=TRUE, include_3D = TRUE, PC_x = 1, PC_y = 2, PC_z=3)

pca_dist <- prcomp(distance, center = TRUE, scale=FALSE)

```


```{r SVM}
set.seed(4685)
data_split <- initial_split(z, strata = "y", p = 0.9)

z_train <- training(data_split)
z_test <- testing(data_split)

svm <- svm_rbf(mode = "classification", cost = 1, rbf_sigma = 0.1)
svm

svm_fit <- 
  svm %>%
  set_engine("kernlab") %>%
  fit_xy(
    x = z[,-ncol(z)],
    y = factor(z$y)
  )
svm_fit

test_results <- 
  z_test %>%
  select(y) %>%
  bind_cols(
    predict(svm_fit, new_data = z_test[,-ncol(z)])
  )

caret::confusionMatrix(factor(test_results[['.pred_class']]), factor(test_results[['y']]))

```

