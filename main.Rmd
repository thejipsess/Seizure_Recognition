---
title: "Seizure Recognition"
author: "Jip de Kok"
date: "9/15/2020"
output:
  html_document: default
  pdf_document: default
---

The data used here is EEG data. Originally there were 500 participants, who
were recorded for 23.5 seconds with 4097 data points per sample. Each sample
was divided into 23 chunks , each containing 178 data points for 1 second.
These chunks were shuffled, resulting in 11500 samples.


5 - (healthy, surface recording) eyes open, means when they were recording the EEG signal of the brain the patient had their eyes open
4 - (healthy, surface recording) eyes closed, means when they were recording the EEG signal the patient had their eyes closed
3 - (epiliptic, intracranial recording) The EEG activity from the hippocampal formation in the non-epiletogenic hemisphere with no seizure
2 - (epiliptic, intracranial recording) The EEG activity from the epileptogenic zone brain area with no seizure
1 - (epiliptic, intracranial recording) Recording of seizure activity



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


This section loads all the the required packages and the data. Also, it removes missing data and splits the data into dependant and independant data.
```{r data, echo=FALSE}
source('packages.R')

# Load data
x = read.csv('Data/data.csv', sep = ';', row.names = 'X')
# Remove rows with missing data
x <- na.omit(x)
# Isolate y
y <- x$y
# remove y column from x
x <- subset(x, select = -y)

```

```{r Data_Inspection}
# Count missing data
nullsum = sum(!complete.cases(x))

theme_set(theme_bw(base_size=12)+ 
  theme(panel.grid.major = element_blank(),
  panel.grid.minor = element_blank()))

# Plot a random sample over time
plot_rand_sample(x)

```

```{r PCA}
# Perform PCA
pca <- prcomp(x, center = TRUE, scale=FALSE)

# Plot PCA
plot_pca(pca)

# Remove the sample with class 70
x <- x[y != 70,]
y <- y[y != 70]

```

```{r Plot_data}
# Create density plot of unnormalised data
plot_dens(x, "Data distribution (not pre-processed)")

# Make violin plots for the different classes
plot_violin(x, y, title = "violin plot for all classes (not pre-processed)")

# Create boxplots
plot_boxplot(x, y)
```


```{r Preprocessing}

# Mean center and scale (divide by stdev) the data
#preproc <- preProcess(x, method=c('center', 'scale'))
#x <- predict(preproc, x)

# Get rid of the most extreme outlier
row_max <- which(x == max(x), arr.ind = TRUE)[1]
y <- y[-row_max]
x <- x[-row_max,]


# Remove univariate outliers
for(i in seq(1, 178)){
  Q1 <- quantile(x[,i], 0.25)
  Q3 <- quantile(x[,i], 0.75)
  IQR <- Q3 - Q1
  uplim <- Q3 + 10*IQR
  downlim <- Q1 - 10*IQR
  
  y <- y[x[names(x)[i]] <= uplim & x[names(x)[i]] >= downlim]
  x <- x[x[names(x)[i]] <= uplim & x[names(x)[i]] >= downlim,]
}

# mean-center: Set mean of each variable to 0
# Scale: Unit variance scaling
preproc <- preProcess(x, method=c('center', 'scale'))
x <- predict(preproc, x)

# Min Max normalisation
for (col in colnames(x)){
  x[col] <- ((x[col] - min(x[col])) / (max(x[col]) - min(x[col])))
}

```


```{r Plot_data}
# Create density plot of unnormalised data
plot_dens(x, "Data distribution (pre-processed)")

# Make violin plots for the different classes
plot_violin(x, y, title = "violin plot for all classes (not pre-processed)")

# Create boxplots
plot_boxplot(x, y)
```


``` {r distance, message=FALSE}
# create matrix z which contains both x and y, only for classes one and two
z <- x
z$y <- y
z <- z[y == 1 | y == 2,]
z <- arrange(z, y)

# Calculate the distance matrix (euclidean distance)
distance <- dist(z[,-y])
distance <- as.matrix(distance)

# Plot heatmap of the distance matrix
hm <- heatmap(distance, Rowv = NA, Colv = NA, labRow = z$y, labCol = z$y, scale="none", main = "Distance heatmap - no scaling")
png(file="Figures/Heatmap.png", antialias = "cleartype", width = 6, height = 6, units = 'in', res = 600)
hm <- heatmap(distance, Rowv = NA, Colv = NA, labRow = z$y, labCol = z$y, scale="none", main = "Distance heatmap - no scaling")
dev.off()

# Perform double centring on the distance matrix
Rmean <- distance*0 + rowMeans(distance)
Cmean <- distance*0 + colMeans(distance)
distance = distance - Rmean - Cmean + mean(distance)

# Plot heatmap of the distance matrix
hm_dc <- heatmap(distance, Rowv = NA, Colv = NA, labRow = z$y, labCol = z$y, scale="none", main = "Distance heatmap - Double centred")
png(file="Figures/Heatmap_dc.png", antialias = "cleartype", width = 6, height = 6, units = 'in', res = 600)
hm_dc <- heatmap(distance, Rowv = NA, Colv = NA, labRow = z$y, labCol = z$y, scale="none", main = "Distance heatmap - Double centred")
dev.off()

# Plot heatmaps in console



# Perform PCA
pca <- prcomp(z[,-y], center = TRUE, scale=FALSE)

pca.var <- pca$sdev^2
pca.var.per <- round(pca.var/sum(pca.var)*100, 1)
barplot(pca.var.per, main="PCA plot", xlab="Principal component", ylab='Percent variation')

pca.data <- data.frame(Sample=z$y, X = pca$x[,1], Y = pca$x[,2])

PCA_euc <- ggplot(data = pca.data, aes(x=X, y=Y, label = Sample, color = factor(Sample))) +
                  geom_point(alpha = 0.5) +
                  xlab(paste("PC1 - ", pca.var.per[1], "%", sep="")) +
                  ylab(paste("PC2 - ", pca.var.per[2], "%", sep="")) +
                  theme_bw() +
                  coord_fixed(1) +
                  ggtitle("PCA plot - Euclidean distance")
PCA_euc
ggsave("Figures/PCA Euclidean distance.png", plot = PCA_euc, device = 'png', dpi=1200)


# 3D PCA
pca3d(pca, group=pca.data$Sample, components = 1:3)
#pca3d(pca, group=pca.data$Sample, components = 4:7)

```

```{r autoCorrelation}
# This section splits the sample information into three different columns
# This is to get info on which samples belong to which individual
# There should be 500 individuals, they have not yet been identified
library(stringr)
# Split sample index into three columns
samples <- data.frame(str_split_fixed(row.names(x), "[.]", 3))
# Remove letters from sample IDs
samples[,1] <- substring(samples[,1],2)
samples[,2] <- substring(samples[,2],2)
# Take info of second column into third column when missing
missing_index <- samples[,3] == ""
samples[missing_index, 3] <-substr(samples[missing_index, 2], 2, 2)
samples[missing_index, 2] <-substr(samples[missing_index, 2], 1, 1)
samples <- sapply(samples, as.integer)
# Set column names
colnames(samples) <- c('Chunk', 'V', 'unknown')


```

