---
title: "Seizure Recognition"
author: "Jip de Kok"
date: "9/15/2020"
output:
  html_document: default
  pdf_document: default
---

The data used here is EEG data. Originally there were 500 participants, who
were recorded for 23.5 seconds with 4097 data points per sample. Each sample
was divided into 23 chunks , each containing 178 data points for 1 second.
These chunks were shuffled, resulting in 11500 samples.


5 - (healthy, surface recording) eyes open, means when they were recording the EEG signal of the brain the patient had their eyes open
4 - (healthy, surface recording) eyes closed, means when they were recording the EEG signal the patient had their eyes closed
3 - (epiliptic, intracranial recording) The EEG activity from the hippocampal formation in the non-epiletogenic hemisphere with no seizure
2 - (epiliptic, intracranial recording) The EEG activity from the epileptogenic zone brain area with no seizure
1 - (epiliptic, intracranial recording) Recording of seizure activity



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



```{r data, echo=FALSE}
source('packages.R')

# Load data
x = read.csv('Data/data.csv', sep = ';', row.names = 'X')
# Remove rows with missing data
x <- na.omit(x)
# Isolate y
y <- x$y
# remove y column from x
x <- subset(x, select = -y)

```

```{r Data_Inspection}
# Count missing data
nullsum = sum(!complete.cases(x))

theme_set(theme_bw(base_size=12)+ 
  theme(panel.grid.major = element_blank(),
  panel.grid.minor = element_blank()))

# Plot a random sample over time
time = seq(1, 178)
x_t <- data.frame(t(x))
x_t$time = time
col = floor(runif(1, min=1, max = 179))
ggplot(x_t, aes(x=time, y=x_t[,col]))+
  geom_line(colour = 'dodgerblue', size = 1)

```

```{r PCA}
# Perform PCA
pca <- prcomp(x, center = TRUE, scale=FALSE)

pca.var <- pca$sdev^2
pca.var.per <- round(pca.var/sum(pca.var)*100, 1)
barplot(pca.var.per, main="PCA plot", xlab="Principal component", ylab='Percent variation')

pca.data <- data.frame(Sample=y, X = pca$x[,1], Y = pca$x[,2])

ggplot(data = pca.data, aes(x=X, y=Y, label = Sample, color = factor(Sample))) +
  geom_point() +
  xlab(paste("PC1 - ", pca.var.per[1], "%", sep="")) +
  ylab(paste("PC2 - ", pca.var.per[2], "%", sep="")) +
  theme_bw() +
  ggtitle("PCA plot")

# Remove the sample with class 70
x <- x[y != 70,]
y <- y[y != 70]

```

```{r Normalisation}

long = melt(x, id.vars = 0)

# Create density plot of unnormalised data
ggplot(long, aes (value)) +
  geom_density() +
  ggtitle("Data distribution (unnormalised)")

# Normalise: mean-center
# Scale: Unit variance scaling
preproc <- preProcess(x, method=c('center', 'scale'))
#preproc <- preProcess(x, method=c('center'))
x <- predict(preproc, x)

long_norm = melt(x, id.vars = 0)

# Create density plot of normalised data
ggplot(long_norm, aes (value)) +
  geom_density() +
  ggtitle("Data distribution (normalised)")


# Make violin plots for the different classes
data_full <- x
data_full$y <- y
res <- melt(data_full, id.vars='y')

# cReate The violin plots
ggplot(res, aes(x = y, y = value, group = y))+
  geom_violin()+
  ggtitle("Violin plot of the different classes")

ggplot(res, aes(x = y, y = value, group=y))+
  geom_boxplot()+
  ggtitle("boxplot of the different classes")+
  xlim(1, 6)

ggplot(long, aes(x = variable, y = value))+
  geom_boxplot()+
  ggtitle("Boxplot of entire dat set")

# Get rid of the most extreme outlier
row_max <- which(x == max(x), arr.ind = TRUE)[1]
y <- y[-row_max]
x <- x[-row_max,]


# Remove univariate outliers
for(i in seq(1, 178)){
  Q1 <- quantile(x[,i], 0.25)
  Q3 <- quantile(x[,i], 0.75)
  IQR <- Q3 - Q1
  uplim <- Q3 + 10*IQR
  downlim <- Q1 - 10*IQR
  
  y <- y[x[names(x)[i]] <= uplim & x[names(x)[i]] >= downlim]
  x <- x[x[names(x)[i]] <= uplim & x[names(x)[i]] >= downlim,]
}


# Repteated plots!!!!!!
long = melt(x, id.vars = 0)

# Create density plot of unnormalised data
ggplot(long, aes (value)) +
  geom_density() +
  ggtitle("Data distribution (unnormalised)")

# Normalise: mean-center
# Scale: Unit variance scaling
preproc <- preProcess(x, method=c('center', 'scale'))
preproc <- preProcess(x, method=c('center'))
x <- predict(preproc, x)

long_norm = melt(x, id.vars = 0)

# Create density plot of normalised data
ggplot(long_norm, aes (value)) +
  geom_density() +
  ggtitle("Data distribution (normalised)")


# Make violin plots for the different classes
data_full <- x
data_full$y <- y
res <- melt(data_full, id.vars='y')

# cReate The violin plots
ggplot(res, aes(x = y, y = value, group = y))+
  geom_violin()+
  ggtitle("Violin plot of the different classes")

ggplot(res, aes(x = y, y = value, group=y))+
  geom_boxplot()+
  ggtitle("boxplot of the different classes")+
  scale_x_discrete(name ="Class", 
                    limits=factor(c(1, 2, 3, 4, 5)))
  

ggplot(long, aes(x = variable, y = value))+
  geom_boxplot()+
  ggtitle("Boxplot of entire dat set") +
  theme(axis.text.x = element_blank(), axis.ticks = element_blank())
```



``` {r NoiseRemoval}




```

```{r test}
library(stringr)
f <- data.frame(str_split_fixed(row.names(x), "[.]", 3))
f[,1:2] <- substring(f[,1:2],2)
colnames(f) <- c('Person', )

# To do: create proper splits of the three sample id's (the columns) and make sure that column three get completely filled, for some their value ended up in column 2.

```

